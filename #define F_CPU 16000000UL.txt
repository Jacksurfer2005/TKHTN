#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>



#define DDR_SPI DDRB
#define DD_MOSI PB3
#define DD_SCK  PB5
#define DD_SS   PB2

#define MATRIX_SIZE 8
#define MAX_LENGTH 32

typedef struct {
	uint8_t x;
	uint8_t y;
} Point;

Point snake[MAX_LENGTH];
uint8_t snake_length = 3;
int8_t dir_x = 0, dir_y = 1; // hướng ban đầu: sang phải
Point food;
uint8_t hang[8];

void led(void){
	for (int i=0;i<8;i++){
		hang[i]=0;
	}
	// vẽ thân rắn
	for (int i=0;i<snake_length;i++){
		hang[snake[i].x] |= (1<<snake[i].y);
	}
	// vẽ thức ăn
	hang[food.x] |= (1<<food.y);
}


void SPI_MasterInit(void) {
	DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<DD_SS);
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); // Enable SPI, Master mode, f/16
}

void SPI_MasterTransmit(uint8_t cData) {
	SPDR = cData;
	while(!(SPSR & (1<<SPIF)));
}

void MAX7219_Send(uint8_t addr, uint8_t data) {
	PORTB &= ~(1<<DD_SS);
	SPI_MasterTransmit(addr);
	SPI_MasterTransmit(data);
	PORTB |= (1<<DD_SS);
}

void MAX7219_Init(void) {
	MAX7219_Send(0x0F, 0x00); // display test: off
	MAX7219_Send(0x0C, 0x01); // shutdown: normal
	MAX7219_Send(0x0B, 0x07); // scan limit = 8 LEDs
	MAX7219_Send(0x0A, 0x08); // intensity: medium
	MAX7219_Send(0x09, 0x00); // decode: none

	for (uint8_t i=1; i<=8; i++) {
		MAX7219_Send(i, 0x00); // clear all
	}
}

// Random từ min đến max (bao gồm cả min và max)
int randomRange(int min, int max) {
	return min + rand() % (max - min + 1);
}


// --- Snake game functions ---
void clearMatrix(void) {
	for (uint8_t i=1; i<=8; i++) {
		MAX7219_Send(i, 0x00);
	}
}

void drawrows(uint8_t x, uint8_t y) {
	if (x <= 8) {
		MAX7219_Send(x, y);
	}
}

void spawnFood(void) {
	int valid;
	do {
		valid = 1;  // giả sử vị trí hợp lệ
		food.x = randomRange(0,7);
		food.y = randomRange(0,7);

		// kiểm tra có trùng với thân rắn không
		for (int i = 0; i < snake_length; i++) {
			if (snake[i].x == food.x && snake[i].y == food.y) {
				valid = 0; // trùng → không hợp lệ
				break;
			}
		}
	} while (!valid); // nếu trùng thì sinh lại
}

uint8_t checkCollision(Point head) {
	for (uint8_t i=1; i<snake_length; i++) {
		if (head.x == snake[i].x && head.y == snake[i].y) return 1;
	}
	return 0;
}

void moveSnake(void) {
	Point newHead;
	newHead.x = (snake[0].x + dir_x + MATRIX_SIZE) % MATRIX_SIZE;
	newHead.y = (snake[0].y + dir_y + MATRIX_SIZE) % MATRIX_SIZE;

	if (checkCollision(newHead)) {
		// Game Over: reset snake
		snake_length = 3;
		snake[0].x = 3; snake[0].y = 4;
		snake[1].x = 3; snake[1].y = 3;
		snake[2].x = 3; snake[2].y = 2;
		dir_x = 1; dir_y = 0;
		spawnFood();
		return;
	}

	for (int i = snake_length; i > 0; i--) {
		snake[i] = snake[i-1];
	}
	snake[0] = newHead;

	if (newHead.x == food.x && newHead.y == food.y) {
		snake_length++;
		//if (snake_length > MAX_LENGTH) snake_length = MAX_LENGTH;
		spawnFood();
	}
}

void check_button(void){
	int e=-1;
	if ((PIND & (1<<PD0)) == 0) {
		e=0;
	}
	if ((PIND & (1<<PD1)) == 0) {
		e=1;
	}
	if ((PIND & (1<<PD2)) == 0) {
		e=2;
	}
	if ((PIND & (1<<PD3)) == 0) {
		e=3;
	}
	if (e==-1) return 0;
	if (e==0){
		dir_x = -1;
		dir_y = 0;
	}else if (e==1){
		dir_x = 0;
		dir_y = -1;
	}else if (e==2){
		dir_x = 0;
		dir_y = 1;
	}else if (e==3){
		dir_x = 1;
		dir_y = 0;
	}
}

int main(void) {
	DDRD=0X00;// PORT INPUT
	PORTD=0XFF;// DIEN TRO KEO
	
	SPI_MasterInit();
	MAX7219_Init();
	snake[0].x = 3; snake[0].y = 4;
	snake[1].x = 3; snake[1].y = 3;
	snake[2].x = 3; snake[2].y = 2;
	snake_length = 3;
	spawnFood();
	while(1){
		clearMatrix();
		check_button();
		moveSnake();
		led();
		for (int i=0;i<8;i++){
			drawrows(i+1,hang[i]);
		}
		_delay_ms(20);
	}
}